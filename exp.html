<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>dromozoa-web</title>
</head>
<body>
<script>
(() => {
  // stackless coroutineでstackful coroutineを実装する
  // 状態遷移機械=CPS=SSA変換すればstackful coroutineはつくれる
  // CPS=SSAを直接実行するにはtail call optimizationがほしい
  // JavaScriptにはない（Safariしか実装していない）
  // 自前でトランポリンを書くか、stackless coroutine=generatorで書く ← ダメでした
  // 自前でトランポリンを書くと、スタックが容易にいじれる
  // generatorを使うと、たぶん、効率的になる
  // Luaはtail call optimizationがあるので、coroutineをつくらなくても必要
  // 完全なSSA=CPS変換でなくてもいい？（良い性質はうしなわれるけど、最適化の必要がなければ）
  // Luaはメタテーブルでいろいろできるので、ほぼすべてが関数呼び出しになりえる

  /*
    -- Luaは自前でスタックを確保しているので、tcoなしの再帰は十万回くらい
    local function f(x)
      -- print(x)
      if x > 0 then
        -- return (f(x - 1)) -- no tco
        return f(x - 1)
      end
    end
   */

  // JavaScriptだと1万回くらい？
  let f = x => {
    // console.log(x)
    if (x > 0) {
      return f(x - 1)
    }
  }

  // yield* function
  let g = function* (x) {
    // console.log(x)
    if (x > 0) {
      // g(x - 1)を呼んで、generatorを作成して、yield*するわけで再帰呼び出しになる
      yield* g(x - 1)
    }
  }

  let h = x => {
    // console.log(x)
    if (x > 0) {
      return () => h(x - 1)
    }
  }

  console.log("started")
  // f(10000)
  // for (i of g(1000)) {}
  let d = h(10000)
  while (true) {
    d = d()
    if (!d) {
      break
    }
  }
  console.log("finished")

/*
  let f = async () => {
    console.log(1)
    await new Promise(resolve => {
      setTimeout(() => resolve(), 500)
    })
    console.log(2)
  }
  let g = () => {
    console.log(3)
  }

  // f().then(() => console.log("then")).catch((e) => console.log("catch", e))

  console.log(f)
  console.log(g)

  setTimeout(f, 0)
  setTimeout(g, 0)

  console.log(4)

  let x = function* () {
    yield 17
    yield 23
    yield 42
    return 69
  }

  let y = function* () {
    let generator = x()
    yield "foo"
    const v = yield* generator
    console.log("yield*", v)
    yield "bar"
    return "baz"
  }

  let i = 0
  let iterator = y()
  while (true) {
    let entry = iterator.next()
    if (entry.done) {
      console.log(++i, entry.value, "finished")
      break
    } else {
      console.log(++i, entry.value)
    }
  }

  // i = 0
  // iterator = x()
  // for (y of iterator) {
  //   console.log(++i, y)
  // }
  // console.log(++i, iterator)
*/

})()
</script>
</body>
</html>
